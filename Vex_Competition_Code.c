#pragma config(Sensor, dgtl5,  green,          sensorLEDtoVCC)
#pragma config(Sensor, dgtl6,  yellow,         sensorLEDtoVCC)
#pragma config(Sensor, dgtl7,  red,            sensorLEDtoVCC)
#pragma config(Motor,  port1,           rightBack,     tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           rightFront,    tmotorNone, openLoop)
#pragma config(Motor,  port3,           leftBack,      tmotorNone, openLoop)
#pragma config(Motor,  port4,           leftFront,     tmotorNone, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

/* USER DEFINED: */

// MAX increases the joystick response of Ch3 and reduces Ch4 proportionally
// so the value of the motor never exceeds 127. range: 0 - 1.
#define MAX 0.7

// MIN is the multiplier for high state of toggle. When active, the values
// of Ch3 and Ch4 are combined and multiplied by MIN.
#define MIN 0.5

void pre_auton()
{
	bStopTasksBetweenModes = true;
}


// function that takes two parameters, left and right. changes value of motor port given in square braces.
void drive(float left, float right) {
	// sets motor on motor[int] to given parameter
	motor[leftFront] = left;
	motor[leftBack] = left;
	motor[rightFront] = right;
	motor[rightBack] = right;
}


task autonomous()
{
	// Remove this function call once you have "real" code.
	AutonomousCodePlaceholderForTesting();
}


task usercontrol()
{
	// used for drive speed
	bool toggleState;
	// prevents state of button used from changing mid-loop.
	int buttonState;
	// circumvents rapid toggling on each loop by ensuring last loop user wasn't holding the button.
	int prevButtonState;

	while (true)
	{
		// sets LED on port "yellow" to buttonState, which is set by Btn8D.
		SensorValue[yellow] = buttonState = vexRT[Btn8D];

		// left joystick control for both, uses max to determine
		if (toggleState)
			drive(vexRT[Ch3] * MAX + vexRT[Ch4] * (1- MAX), vexRT[Ch3] * MAX - vexRT[Ch4] * (1 - MAX));

		else
			drive((vexRT[Ch3] + vexRT[Ch4]) * MIN, (vexRT[Ch3] - vexRT[Ch4]) * MIN );


		// reverses state of toggle if button is pressed and wasn't pressed in previous loop.
		if (buttonState && prevButtonState != buttonState)
			SensorValue[red] = toggleState = !toggleState;

		// sets prevButtonState to curr. button state.
		prevButtonState = buttonState;
	}
}
